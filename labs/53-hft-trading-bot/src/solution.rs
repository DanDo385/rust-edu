//! # Lab 53 Solution: HFT Trading Bot Core
//!
//! This module models a tiny high-frequency-trading (HFT) core. We are
//! building deterministic strategy decisions plus risk checks that guard
//! leverage and exposure. The goal is to teach how trading logic can stay
//! deterministic while still respecting ownership and borrowing rules.
//!
//! ## Classroom Narrative
//! 1. **Inputs/ownership**: `TradingConfig` owns strategy parameters, symbols, and limits. All functions borrow `&TradingConfig`, so readers see the same configuration without copying.
//! 2. **Risk modeling**: `RiskState` is `Copy`, so we pass it by value. This is a shallow (stack) copy, not a heap allocation. Mutable state (orders) is modeled by `CandidateOrder`, which is also `Copy`.
//! 3. **Decision path**: `can_place_order` checks size bounds, max position, and loss thresholds in lockstep. Each test is a read-only borrow of `TradingConfig` plus stack-local calculations.
//!
//! ## Symbol Drill
//! - `&TradingConfig`: shared borrow; we pass an address and use the values without taking ownership.
//! - `RiskState` and `CandidateOrder` are `Copy`, so they move by copying stack bytes, not heap data.
//! - No `*` usages here, so the import is front-loaded on arithmetic closures.
//!
//! ## Step-by-step Teaching Breakdown
//! 1. **Validation**: `validate` carefully inspects each limit. Strings (`symbol`) are borrowed immutably, just reading the heap-owned bytes. Error strings are `String` clones produced only on failure so we don’t duplicate data when inputs are valid.
//! 2. **Risk check**: `can_place_order` first ensures `size` sits within `[0, max_order_size]` — these are scalar stack comparisons. Then it calculates `resulting_position` based on the `Side`; the variable is a stack scalar showing how buys/sells shift exposure.
//! 3. **Position & loss guards**: We compare `resulting_position.abs()` against `cfg.max_position` and `risk.unrealized_pnl` against `-cfg.max_loss`. These checks are deterministic and borrow only stack values.
//! 4. **Quoting helpers**: `make_market_making_quotes` constructs buy/sell orders by copying the `mid_price` scalar twice, showing how to keep symmetry between sides with minimal heap activity.

/// Strategy selected for quoting.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum StrategyType {
    MarketMaking,
    Momentum,
    Arbitrage,
}

/// Trading configuration used by the strategy and risk checks.
#[derive(Debug, Clone)]
pub struct TradingConfig {
    pub symbol: String,
    pub strategy: StrategyType,
    pub max_position: f64,
    pub max_loss: f64,
    pub max_order_size: f64,
}

impl TradingConfig {
    pub fn validate(&self) -> Result<(), String> {
        if self.symbol.trim().is_empty() {
            return Err("symbol must not be empty".to_string());
        }
        if self.max_position <= 0.0 {
            return Err("max_position must be positive".to_string());
        }
        if self.max_loss <= 0.0 {
            return Err("max_loss must be positive".to_string());
        }
        if self.max_order_size <= 0.0 {
            return Err("max_order_size must be positive".to_string());
        }
        Ok(())
    }
}

/// Snapshot of current risk state.
#[derive(Debug, Clone, Copy)]
pub struct RiskState {
    pub position: f64,
    pub unrealized_pnl: f64,
}

/// Direction of a candidate order.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Side {
    Buy,
    Sell,
}

/// Candidate order generated by a strategy.
#[derive(Debug, Clone, Copy)]
pub struct CandidateOrder {
    pub side: Side,
    pub price: f64,
    pub size: f64,
}

/// Returns whether this order can be placed without violating risk limits.
pub fn can_place_order(cfg: &TradingConfig, risk: RiskState, order: CandidateOrder) -> bool {
    if order.size <= 0.0 || order.size > cfg.max_order_size {
        return false;
    }

    let resulting_position = match order.side {
        Side::Buy => risk.position + order.size,
        Side::Sell => risk.position - order.size,
    };

    if resulting_position.abs() > cfg.max_position {
        return false;
    }

    if risk.unrealized_pnl <= -cfg.max_loss {
        return false;
    }

    true
}

/// Generate a simple two-sided quote around a fair price.
pub fn make_market_making_quotes(mid_price: f64, half_spread: f64, size: f64) -> (CandidateOrder, CandidateOrder) {
    let bid = CandidateOrder {
        side: Side::Buy,
        price: mid_price - half_spread,
        size,
    };
    let ask = CandidateOrder {
        side: Side::Sell,
        price: mid_price + half_spread,
        size,
    };
    (bid, ask)
}
